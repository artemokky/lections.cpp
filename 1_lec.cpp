#include <iostream>
using std::cout;
using std::endl;
using std::string;

//1st lection

/* Содержание лекции:
*
* 1. Структура классов
* 2. Наследование и уровни доступа классов
* 3. Правило конструкирование объектов
* 4. Неявный вызов конструктора и ключевое слово - explicit
* 5. Наследование конструкторов
* 6. Операции классов по умолчанию
* 7. Деструкторы
* 8. Виртуальные функции
* 9. override & final 
* 10. Рекомендации к проектированию
* 11. Заключение
* 
*/

void Topic1() { // Структура классов

	// Тип данных(класс или объект) = данные + метод
	class A {
		int a; // Поля класса
		double b;
		char c;

		int method1() { return 0; } // Методы класса
		void method2() { cout << "method" << endl; }
	};
}

void Topic2() { // Наследование и уровни доступа классов

//| Доступ к полям & методам| public | protected | private |
////// |Доступ вне класса   |    +   |     -     |    -    |
////// |Доступ у наследников|    +   |     +     |    -    |
////// |Доступ внутри класса|    +   |     +     |    +    |

	class A 
	{
	// default у класса - private
		char c; //private поле
	public: 
		int a;
	protected:
		double b;
	public:
		void method(int num) { cout << num << endl; }
	protected:
		int method1() { return 0; }
	private:
		void method2() { cout << "method" << endl; }
	};

	class B : public A // public - означает что максимальный уровень доступа будет ограничен как public
		               // если задать наследование как protected - все public поля заменятся на protected
	{
	public:
		void methods() {
			method(1); // Ok
			method1(); // Ok
			//method2(); // Error

			a = 10;    // Ok
			b = 0.0;   // Ok
			//c = 'c';   // Error
		}
	};

	A a;
	B b;

	a.method(1); // Ok
	//a.method1(); // Error
	//a.method2(); // Error

	a.a = 100; // Ok
	//a.b = 1.0; // Error
	//a.c = 'C'; // Error

}

void Topic3() {// Правило конструирования объектов

	/*
	* Конструирование по "слоям":
	* - от самого первого предка(производный класс) к конструирующемуся объекту
	* - слой = создание полей + вызов тела конструктора
	* - порядок вызова - порядок объявления (верно как для предков, так и для полей)
	*/

	class A
	{
	public:
		A() { cout << "A" << endl; }
		A(int a) { cout << "0->A" << endl; }
	};

	class B : public A
	{
	public:
		B() { cout << "B" << endl; }
		B(const A& a) : A(1) { cout << "A->B" << endl; }
	};

	class C : public A, private B // Порядок объявления - определяет порядок вызова конструкторов
	{
	public:
		C() : m_a(), A(), B(m_a) // Cписок инициализации - указание конкретных конструкторов полей и предков
			                     // Не определяет порядок вызова конструкторов
		{ cout << "C" << endl; }
	private:
		A m_a;
	};

	C c;

	/*
	* Output:
	* 0->A  (C::B::A)
    * A->B  (C::B)
    * A     (C::A)
    * A     (C::m_a)
    * C     (C)
	* 
	* Если поменять порядок объявления на public A, private B, то будет вывод:
	* 
	* Output:
	* A     (C::A)
    * 0->A  (C::B::A)
    * A->B  (C::B)
    * A     (C::m_A)
    * C     (C)
	*/

}

void Topic4() { // Неявный вызов конструктора и ключевое слово - explicit 

	// explicit - запрет неявного вызова конструктора
	// может быть применен к операторам конвертации
	// конвертирующий конструктор - конструктор с одним параметром, объявленный без ключевого слова explicit (до C++11)


	class A
	{
	public:
		A() { cout << "A" << endl; }
		A(int a) { cout << "0->A" << endl; }
	};

	A a = 5; // Неявный вызов конструктора A(int a), конвертирующий конструктор

	class B
	{
	public:
		B() { cout << "B" << endl; }
		explicit B(int b)  { cout << "0->B" << endl; } // Неявный вызов запрещен
		B(int, int) { cout << "(1, 1)->B" << endl; }

	};

	//B b = 10; // Error, так как перед определением конструктора стоит explicit, запрещающий неявный вызов конструктора B(int b)
	B b(10);  // Ok
	B b = { 1, 2 }; // Ok (since C++11)
}

void Topic5() { // Наследование конструкторов

	// Конструкторы базового класса в общем случае не наследуются в производном
	// В случае необходимости конструировать производный класс как базовый в C++11 используется using
	// Если производный класс реализует конструктор с той же сигнатурой, что и предок, то вызываться будет конструктор производного класса

	class A
	{
	public:
		A() { cout << "A" << endl; }
		A(int a) { cout << "0->A" << endl; }
		A(int, int) { cout << "(1, 1)->A" << endl; }
	};

	class B : public A
	{
	public:
		using A::A;
		B() { cout << "B" << endl; }
		B(const A& a) : A(1) { cout << "A->B" << endl; }
		//B(int, int) { cout << "(1, 1)->B" << endl; }
	};


	B a0; //ok
	B a1 = 5; //ok, без using будет error
	B a2 = { 4, 5 }; //ok, без using будет error

	/*
	* Output:
	* 
	* A           (B::A)
    * B           (B)
    * 0->A        (B::A)
    * (1, 1)->A   (B::A)
	* 
	* Вывод, если раскомментировать конструктор B(int, int)
	* Output:
	* 
    * A           (B::A)
    * B           (B)
    * 0->A        (B::A)
    * A           (B::A)
    * (1, 1)->B   (B)
	*/
}

void Topic6() { // Операции классов по умолчанию
	/*
	* (Генерируются автоматически, если нет пользовательского аналога)
	* 
	* A() - Конструктор по умолчанию – вызывает к-торы без параметров у предков и полей в порядке объявления. 
	* A(const& A) - Копирующий конструктор
	* A& operator= (A const&) - Оператор копирования
	* ~A() - Деструктор, по умолчанию noexcept, виртуальный в случае, если в базовом классе деструктор виртуален
	*/
}

void Topic7() { // Деструкторы
	/*
	* Удаление происходит в порядке, обратном конструированию:
	* 1. Вызов тела деструктора
	* 2. Удаление полей класса
	* 3. Удаление предков класса
	* 
	* (2 и 3 осуществляются в порядке, обратном объявлению предков/полей)
	*/
}

void Topic8() { // Виртуальные функции
	/*  
	*   -Реализация динамического полиморфизма
	* 
	*	-Таблица виртуальных функций определяется на конструкторе
	* 
	*	-Чисто виртуальные функции:
	*	1.Не имеют реализации в базовом классе
	* 
	*	-Виртуальные деструкторы:
	*	1.Нужны для корректного удаления указателей на базовый класс, созданных конструктором наследника
	* 
	*	-Чисто виртуальные деструкторы:
	*	1.Запрещают создание объектов базового класса
	*	2.Чисто виртуальный деструктор все равно должен иметь реализацию
	*/

	class A
	{
	public:
		virtual void print() { cout << "A"; }
	};

	class B : public A
	{
	public:
		virtual void print() { cout << "B"; }
	};

	class C {
	public:
		void print(A* a)
		{
			//Будет вызвана функция того класса, который хранится в указателе А*
			//В данном случае таким классом может быть класс А или класс B
			a->print();
		}
	};
	
	C c;
	A* a = new A;
	A* b = new B; // Динамический полиморфизм

	//Вызов виртуальных функций
	c.print(a); // output: A
	c.print(b); // output: B


}

void Topic9() { // override & final 
	/*
	* 
	* override - функция обязана перекрывать объявление
	* виртуального базового метода.
	* Проверка на стадии компиляции
	* Не влияет на производительность кода, только улучшает его понимание
	* Гарантирует переопределение вирт. функции
	* 
	* final - применяется и к методам и к классам
	* В 99% - наследование реализации стоит запрещать
	* Дает возможность компиллятору для оптимизации
	* 
	* class A final - запрещает дальнейшее наследование
	* 
	* virtual void f(int) const final - запрещает переопределение в наследниках
	* (только для виртуальных функций
	* 
	*/

	struct A {
		virtual void foo();
		void bar();
	};

	struct B : A {
		//void foo() const override; // Error
		void foo() override; // Ok
		//void bar() override; // Error
	};


	class IBase
	{
	public:
	  virtual void f() = 0;
	};

	class CDerived : public IBase
	{
	public:
		void f() override final { _x = 1; } // компиллятор может подставить
		                                    // прямой вызов без вирт указателя
		                                    // или за-inline-ить
		void g(void) { f(); }
	private:
		int _x = 0;
	};


}

void Topic10() { // Рекомендации к проектированию
	/*
	* Признаки плохого проекта:
	* 1.Жесткость
	* -Каждое изменение вызывает множество других изменений
	* 
	* 2.Хрупкость
	* -Изменения приводят к разрушению системы в местах,
	* концептуально несвязанных с точкой изменения
	* 
	* 3.Монолитность
	* -Систему трудно разделить на компоненты для повторного использования
	* 
	* 4.Вязкость
	* -Трудно вносить "правильные" изменения, нежели "неправильные"
	* 
	* 5.Неоправданная сложность
	* -Часть инфраструктуры является избыточной и не приносит пользы
	* 
	* 6.Неоправданная повторяемость
	* -Некие повторяющиеся структуры можно унифицировать в виде абстракции
	* 
	* 7.Непрозрачность
	* -Код трудно читать и понимать
	*/

	/*
	* Деградация проекта:
	* 
	* Причины:
	* Требования изменяются путями, которые не были предусмотрены
	* Решение:
	* -Каждое новое изменение должно провоцировать
	* создание "решения-иммунитета" к подобным изменением
	* -Переодичный рефакторинг - пересмотр архитектуры с учетом требований
	*/
}

void Topic11() { // Заключение
	/*
	* -Классы = поля и данные
	* 
	* -Наследование public = отношение «является» (С точки зрения поведения)
	* 
	* -Виртуальные функции:
	* 1.Реализованы через указатель на таблицу вирт. Функций
	* 2.Определяют поведение кода в процессе работы приложения
	* 
	* -Конструирование объекта:
	* 1.По «слоям» - предки, поля, тело к-тора
	* 2.Запрет неявного вызова к-тора – explicit
	* 3.Наследование к-торов базового класса А (using A::A)
	* 
	* -Гибкое проектирование:
	* 1.Признаки деградации проекта проявляются при некорректной обработке изменений требований
	* 2.Каждый новый тип изменений требований должен быть реализован, обеспечивая «иммунитет» архитектуры к себе подобным
	*/
}